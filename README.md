## Вопросы

---

### Какой самый эффективный способ конкатенации строк?

Строки являются неизменяемым типом данных.
При стандартной конкатенации каждый раз будет создаваться новая строка.
Чтобы избежать этой проблемы необходимо использовать `strings.Builder`
```go
sb := &strings.Builder{}
sb.WriteString("one")
sb.WriteString("two")
sb.WriteString("three")
sb.String()
// Output: onetwothree

```

### Что такое интерфейсы и как они применяются?

Интерфейс - тип данных, с помощью которого реализуется полиморфизм и IoC.
Интерфейс представляет собой структуру:
```go
type iface struct {
    tab  *itab
    data unsafe.Pointer
}
```
`tab` — это указатель на Interface Table или `itable` — структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса.
`data` — указывает на фактическую переменную с конкретным (статическим) типом.

В целом интерфейс — это абстрактный тип даннных, который описывает методы, которые должны быть реализовываны в структурном типе. Если для какой-то структуры определены все методы какого-то интерфейса, считается, что она удовлетворяет этому интерфейсному типу.
Явная имплементация интерфейса (как например в Java) не требуется.

Интерфейсы можно использовать как обычные типы, указывая их в параметрах функций, элементах слайсов и мап, полях структур. Так, функция может принять в параметре переменную интерфейсного типа и вызвать для неё любой из методов этого типа. Таким образом реализуется концепция полиморфизма.

### Чем отличаются RWMutex от Mutex?

Мьютексы применяются, если горутина читает или изменяет данные, которые могут использоваться другим потоком.
Для переменной типа sync.Mutex можно вызвать два метода:
```go
(m *Mutex) Lock() // блокирует мьютекс. 
(m *Mutex) Unlock() // разблокирует мьютекс. 
```
Занять мьютекс может только одна горутина. Если другие горутины вызовут метод Lock() для занятого мьютекса, они будут ждать, пока он освободится.
Горутина должна освободить мьютекс сразу после того, как она закончила работу с общим ресурсом.

Стандартный `Mutex` неоптимален с точки зрения производительности, если операции чтения происходят чаще операций записи.

Тип `sync.RWMutex` позволяет выполнять либо произвольное количество операций чтения, либо одну операцию записи. 
При этом нельзя выполнять две операции записи или одновременно запись и чтение.

### Чем отличаются буферизированные и не буферизированные каналы?

Каналы создаются следующим образом:
```go
make(chan тип) // небуферизирвоанный канал
make(chan тип,  ёмкость) // буферизированный канал
```

Небуферизированные каналы:

- При отправке значения в канал: горутина заблокируется до момента, пока из канала не будет прочитано сообщение
- При получении значения из канала: горутина заблокируется, пока в канал не поступит сообщение

Буферизированные каналы:

- При отправке значения в канал: горутина не заблокируется пока не заполнится буфер. Если буфер полон - горутина блокируется до момента пока изи канала не будет прочитано хотя бы одно сообщение
- При получении значения из канала: если в буфере есть сообщения - горутина получит очередное сообщение сразу. Если буфер пуст - горутина блокируется пока в канал не поступит хотя бы одно сообщение.

### Какой размер у структуры struct{}{}?

без учета накладных расходов сама "пустая" структуру занимает в памяти 0 байт.
С помощью такой структуры удобно создавать множества (аналог Set из Java).

### Есть ли в Go перегрузка методов или операторов?

Нет, такие возможности в Go отсутствуют.

### В какой последовательности будут выведены элементы map[int]int?
```go
//Пример:
m[0]=1
m[1]=124
m[2]=281
```
Итерация по map в Go происходит в случайном порядке.
Добиться явного порядка можно итерируясь, например, по слайсу ключей с получением соответствующего значения по ключу.

### В чем разница make и new?

`new` - аллоцирует память под структуру, но не иницииализирует её, только проставляет "нулевые" занчения. Возвращает указатель.

`make` - используется для инициализации каналов, слайсов и мап (т.к. они должны быть иницииализизрованы перед использованием). Возвращает значение.

### Сколько существует способов задать переменную типа slice или map?

```go
var slice []type 
slice := []type{}
slice := []type{val1, val2, val3}

array := [5]type{}
slice := array[:]

slice := make([]type, 0)
slice := make([]type, 0, 5)

var m map[comparable]type // not initialized
m := make(map[comparable]type)
m := map[comparable]type{key: value, key2: value2}
```

### Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a // в p кладем указатель на a
  )
  fmt.Println(*p) // разыменованываем p и печатаем (читаем значение, на которое указывает указатель)
  update(p) // передаем указатель в функцию, указатель копируется
  fmt.Println(*p) // вновь делаем dereference и читаем значение по указателю p
}

// Output: 
// 1
// 1
```
В функцию `update()` передается копия указателя. Несмотря на то, что переданный указатель внутри функции меняется - результат не возвращается и не перезаписывается в `p`

Поэтому фактически указатель `p` в функции `main()` не меняется, по dereference мы получаем переменную `a`

### Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) { // заменить на wg *sync.WaitGroup
        fmt.Println(i)
        wg.Done()
     }(wg, i) // заменить на &wg 
  }
  wg.Wait()
  fmt.Println("exit")
}
// Output: 
// 2
// 3
// 0
// 1
// 4
// deadlock
```
Выведет цифры 0-4 в случайном порядке и deadlock, т.к. горутина `main` не сможет дождаться `wg.Wait()`
Для решение проблемы необходимо передавать wg по указателю (сейчас передается копия)

### Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
// Output: 
// 0
}
```
n переопределена в скоупе if true

### Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
// Output: 
// [100 2 3 4 5]
```

Первое действие - замена [0] элемента слайса на 100
Второе действие - добавление элемента к слайсу.
Функци append() возвращает новый слайс. 
Но сама функция someAction() ничего не возвращает.

### Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
// Output:
// [b b a][a a]
```
В функции произошло расширение слайса - создался новый базовый массив.
Первоначальный слайс не изменился.

 

