package main

import "fmt"

/*
	Реализовать быструю сортировку массива (quicksort) встроенными методами языка.
*/

/*
	Быстрая in-place сортировка основана на стратегии "разделяй и властвуй".
	In-place означает, что все операции совершаются в текущем массиве, дополнительные массивы не создаются (доп. память не требуется).
	1. Выбираем опорный элемент (обычно первый, последний или средний).
	2. Разделяем массив относительно опорного на две части, при этом элементы "меньше" опорного окажутся слева, элементы "больше" - справа.
	3. Рекурсивно вызываем сортировку для двух частей, который получились относительно индекса для разделения массива в операции 2.
	4. Процесс будет продолжаться пока не останется один элемент в подмассиве (а значит массив отсортирован полностью).

	Задается функция компаратор для определения порядка сортировки.
*/

func main() {
	a := []int{5, 3, 6, 2, 10, 15, 17}
	quicksort(a, 0, len(a)-1)
	fmt.Println(a)
}

func comparator(a, b int) bool {
	return a > b
}

func quicksort(arr []int, left, right int) {
	if left < right {
		divideIdx := partSort(arr, left, right, comparator)
		// разделяем массив на две части
		quicksort(arr, left, divideIdx)
		quicksort(arr, divideIdx+1, right)
	}
}

func partSort(arr []int, left, right int, compare func(a, b int) bool) int {
	//выбираем опорный элемент
	pivot := arr[(left+right)/2]
	for {
		// двигаемся слева направо до тех пор, пока не встретим значение ">" опорного
		for compare(pivot, arr[left]) {
			left++
		}
		// двигаемся справа налево до тех пор, пока не встретим значение "<" опорного
		for compare(arr[right], pivot) {
			right--
		}
		// определяем индекс для разделения массива
		if left >= right {
			return right
		}
		// меняем значения местами (в центре опорный элемент)
		arr[left], arr[right] = arr[right], arr[left]
		// сдвигаем указатели после замены, чтобы продолжить цикл
		left++
		right--
	}
}
